#!/usr/bin/env python3
"""Fast docling server using DocumentConverter singleton.

A lightweight FastAPI server optimized for hybrid PDF processing:
1. Using a DocumentConverter singleton (no per-request initialization)
2. Returns only JSON (DoclingDocument format) - markdown/HTML generated by Java

Usage:
    python scripts/docling_fast_server.py [--port PORT] [--host HOST]

    # Default: http://localhost:5002
    python scripts/docling_fast_server.py

    # Custom port
    python scripts/docling_fast_server.py --port 5003

API Endpoints:
    GET  /health              - Health check
    POST /v1/convert/file     - Convert PDF to JSON

The /v1/convert/file endpoint parameters:
    - files: PDF file (multipart/form-data)
    - page_range: Page range to process (optional)

Note: OCR and table structure detection are always enabled (fixed at startup).
"""

import argparse
import os
import sys
import tempfile
import time
from contextlib import asynccontextmanager
from typing import Optional

import uvicorn
from fastapi import FastAPI, File, Form, UploadFile
from fastapi.responses import JSONResponse

# Docling imports
from docling.datamodel.base_models import InputFormat
from docling.datamodel.pipeline_options import (
    EasyOcrOptions,
    PdfPipelineOptions,
    TableFormerMode,
    TableStructureOptions,
)
from docling.document_converter import DocumentConverter, PdfFormatOption

# Configuration
DEFAULT_HOST = "0.0.0.0"
DEFAULT_PORT = 5002

@asynccontextmanager
async def lifespan(_app: FastAPI):
    """Lifespan context manager for startup and shutdown events."""
    global converter
    print("Initializing DocumentConverter...", flush=True)
    start = time.perf_counter()
    converter = create_converter()
    elapsed = time.perf_counter() - start
    print(f"DocumentConverter initialized in {elapsed:.2f}s", flush=True)
    yield
    # Cleanup on shutdown (if needed)


app = FastAPI(
    title="Docling Fast Server",
    description="Fast PDF conversion using docling SDK with singleton pattern",
    version="1.0.0",
    lifespan=lifespan,
)

# Global converter instance (initialized on startup)
converter: Optional[DocumentConverter] = None


def create_converter(do_ocr: bool = True, do_table_structure: bool = True) -> DocumentConverter:
    """Create a DocumentConverter with the specified options."""
    pipeline_options = PdfPipelineOptions(
        do_ocr=do_ocr,
        do_table_structure=do_table_structure,
        ocr_options=EasyOcrOptions(force_full_page_ocr=False),
        table_structure_options=TableStructureOptions(
            mode=TableFormerMode.ACCURATE
        ),
    )

    return DocumentConverter(
        format_options={
            InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)
        }
    )


@app.get("/health")
def health():
    """Health check endpoint."""
    return {"status": "ok"}


@app.post("/v1/convert/file")
async def convert_file(
    files: UploadFile = File(...),
    page_ranges: Optional[str] = Form(default=None),
):
    """Convert PDF file to JSON (DoclingDocument format).

    Only JSON output is provided - markdown and HTML are generated by
    Java processors for consistent reading order application.

    Note: OCR and table structure detection are always enabled.
    The DocumentConverter is initialized once at startup with fixed options
    for optimal performance.

    Args:
        files: The PDF file to convert
        page_ranges: Page range string "start-end" (e.g., "1-5") (optional)

    Returns:
        JSON response with document content.
    """
    global converter

    if converter is None:
        return JSONResponse(
            {"status": "failure", "errors": ["Server not initialized"]},
            status_code=503,
        )

    # Parse page_ranges string to tuple
    page_range_tuple = None
    if page_ranges:
        try:
            parts = page_ranges.split("-")
            if len(parts) == 2:
                page_range_tuple = (int(parts[0]), int(parts[1]))
        except ValueError:
            pass

    # Save uploaded file to temp location
    with tempfile.NamedTemporaryFile(suffix=".pdf", delete=False) as tmp:
        content = await files.read()
        tmp.write(content)
        tmp_path = tmp.name

    try:
        start = time.perf_counter()
        if page_range_tuple:
            result = converter.convert(tmp_path, page_range=page_range_tuple)
        else:
            result = converter.convert(tmp_path)
        processing_time = time.perf_counter() - start

        # Export to JSON (DoclingDocument format)
        json_content = result.document.export_to_dict()

        # Build response compatible with docling-serve format
        response = {
            "status": "success",
            "document": {
                "json_content": json_content,
            },
            "processing_time": processing_time,
        }

        return JSONResponse(response)

    except Exception as e:
        return JSONResponse(
            {
                "status": "failure",
                "errors": [str(e)],
            },
            status_code=500,
        )
    finally:
        os.unlink(tmp_path)


def main():
    """Run the server."""
    parser = argparse.ArgumentParser(description="Docling Fast Server")
    parser.add_argument(
        "--host",
        default=DEFAULT_HOST,
        help=f"Host to bind to (default: {DEFAULT_HOST})",
    )
    parser.add_argument(
        "--port",
        type=int,
        default=DEFAULT_PORT,
        help=f"Port to bind to (default: {DEFAULT_PORT})",
    )
    parser.add_argument(
        "--log-level",
        default="info",
        choices=["debug", "info", "warning", "error"],
        help="Log level (default: info)",
    )
    args = parser.parse_args()

    print(f"Starting Docling Fast Server on http://{args.host}:{args.port}", flush=True)
    uvicorn.run(
        app,
        host=args.host,
        port=args.port,
        log_level=args.log_level,
    )


if __name__ == "__main__":
    main()
