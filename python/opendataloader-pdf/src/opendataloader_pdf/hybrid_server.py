#!/usr/bin/env python3
"""Fast docling server using DocumentConverter singleton.

A lightweight FastAPI server optimized for hybrid PDF processing:
1. Using a single DocumentConverter instance (no per-request initialization)
2. Returns only JSON (DoclingDocument format) - markdown/HTML generated by Java

Usage:
    opendataloader-pdf-hybrid [--port PORT] [--host HOST] [--ocr-lang LANG] [--force-ocr]
                              [--enrich-formula] [--enrich-picture-description]

    # Default: http://localhost:5002
    opendataloader-pdf-hybrid

    # Custom port
    opendataloader-pdf-hybrid --port 5003

    # Chinese + English OCR with force full-page OCR
    opendataloader-pdf-hybrid --ocr-lang "ch_sim,en" --force-ocr

    # Korean OCR
    opendataloader-pdf-hybrid --ocr-lang "ko"

    # With formula enrichment (LaTeX extraction)
    opendataloader-pdf-hybrid --enrich-formula

    # With picture description (alt text generation)
    opendataloader-pdf-hybrid --enrich-picture-description

    # Combined: OCR + enrichments
    opendataloader-pdf-hybrid --ocr-lang "en" --enrich-formula --enrich-picture-description

API Endpoints:
    GET  /health              - Health check
    POST /v1/convert/file     - Convert PDF to JSON

The /v1/convert/file endpoint parameters:
    - files: PDF file (multipart/form-data)
    - page_ranges: Page range to process (optional)

Requirements:
    Install with hybrid extra: pip install opendataloader-pdf[hybrid]
"""

import argparse
import logging
import os
import tempfile
import time
import traceback
from contextlib import asynccontextmanager
from typing import Optional

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)

# Configuration
DEFAULT_HOST = "0.0.0.0"
DEFAULT_PORT = 5002
MAX_FILE_SIZE = 100 * 1024 * 1024  # 100MB max file size

# Global converter instance (initialized on startup with CLI options)
converter = None


def _check_dependencies():
    """Check if hybrid dependencies are installed."""
    missing = []
    try:
        import uvicorn  # noqa: F401
    except ImportError:
        missing.append("uvicorn")
    try:
        import fastapi  # noqa: F401
    except ImportError:
        missing.append("fastapi")
    try:
        import docling  # noqa: F401
    except ImportError:
        missing.append("docling")

    if missing:
        raise ImportError(
            f"Missing dependencies: {', '.join(missing)}. "
            "Install with: pip install opendataloader-pdf[hybrid]"
        )


DEFAULT_PICTURE_DESCRIPTION_PROMPT = "Describe what you see in this image. Include any text, numbers, labels, and data values visible."


def create_converter(
    force_full_page_ocr: bool = False,
    ocr_lang: list[str] | None = None,
    enrich_formula: bool = False,
    enrich_picture_description: bool = False,
    picture_description_prompt: str | None = None,
):
    """Create a DocumentConverter with the specified options.

    Args:
        force_full_page_ocr: If True, force OCR on all pages regardless of text content.
                            If False (default), OCR only where needed.
        ocr_lang: List of EasyOCR language codes (e.g., ["ch_sim", "en"]).
                  If None, uses EasyOCR default languages.
        enrich_formula: If True, enable formula enrichment (LaTeX extraction).
        enrich_picture_description: If True, enable picture description (alt text generation).
        picture_description_prompt: Custom prompt for picture description. If None, uses default.
    """
    from docling.datamodel.base_models import InputFormat
    from docling.datamodel.pipeline_options import (
        EasyOcrOptions,
        PdfPipelineOptions,
        PictureDescriptionVlmOptions,
        TableFormerMode,
        TableStructureOptions,
    )
    from docling.document_converter import DocumentConverter, PdfFormatOption

    ocr_options = EasyOcrOptions(force_full_page_ocr=force_full_page_ocr)
    if ocr_lang:
        ocr_options.lang = ocr_lang

    # Configure picture description options with custom prompt
    picture_description_options = None
    if enrich_picture_description:
        prompt = picture_description_prompt or DEFAULT_PICTURE_DESCRIPTION_PROMPT
        picture_description_options = PictureDescriptionVlmOptions(
            repo_id="HuggingFaceTB/SmolVLM-256M-Instruct",
            prompt=prompt,
            generation_config={"max_new_tokens": 300, "do_sample": False},
        )

    pipeline_kwargs = {
        "do_ocr": True,
        "do_table_structure": True,
        "ocr_options": ocr_options,
        "table_structure_options": TableStructureOptions(mode=TableFormerMode.ACCURATE),
        "do_formula_enrichment": enrich_formula,
        "do_picture_description": enrich_picture_description,
        "generate_picture_images": enrich_picture_description,
    }
    if picture_description_options is not None:
        pipeline_kwargs["picture_description_options"] = picture_description_options

    pipeline_options = PdfPipelineOptions(**pipeline_kwargs)

    return DocumentConverter(
        format_options={
            InputFormat.PDF: PdfFormatOption(pipeline_options=pipeline_options)
        }
    )


def create_app(
    force_ocr: bool = False,
    ocr_lang: list[str] | None = None,
    enrich_formula: bool = False,
    enrich_picture_description: bool = False,
    picture_description_prompt: str | None = None,
):
    """Create and configure the FastAPI application.

    Args:
        force_ocr: If True, force full-page OCR on all pages.
        ocr_lang: List of EasyOCR language codes (e.g., ["ch_sim", "en"]).
        enrich_formula: If True, enable formula enrichment (LaTeX extraction).
        enrich_picture_description: If True, enable picture description (alt text generation).
        picture_description_prompt: Custom prompt for picture description.
    """
    from fastapi import FastAPI, File, Form, UploadFile
    from fastapi.responses import JSONResponse

    @asynccontextmanager
    async def lifespan(_app: FastAPI):
        """Lifespan context manager for startup and shutdown events."""
        global converter
        lang_str = ",".join(ocr_lang) if ocr_lang else "default"
        enrichments = []
        if enrich_formula:
            enrichments.append("formula")
        if enrich_picture_description:
            enrichments.append("picture-description")
        enrichment_str = ",".join(enrichments) if enrichments else "none"
        logger.info(
            f"Initializing DocumentConverter "
            f"(force_ocr={force_ocr}, lang={lang_str}, enrichments={enrichment_str})..."
        )
        start = time.perf_counter()

        converter = create_converter(
            force_full_page_ocr=force_ocr,
            ocr_lang=ocr_lang,
            enrich_formula=enrich_formula,
            enrich_picture_description=enrich_picture_description,
            picture_description_prompt=picture_description_prompt,
        )

        elapsed = time.perf_counter() - start
        logger.info(f"DocumentConverter initialized in {elapsed:.2f}s")
        yield
        # Cleanup on shutdown (if needed)

    app = FastAPI(
        title="Docling Fast Server",
        description="Fast PDF conversion using docling SDK with singleton pattern",
        version="1.0.0",
        lifespan=lifespan,
    )

    @app.get("/health")
    def health():
        """Health check endpoint."""
        return {"status": "ok"}

    @app.post("/v1/convert/file")
    async def convert_file(
        files: UploadFile = File(...),
        page_ranges: Optional[str] = Form(default=None),
    ):
        """Convert PDF file to JSON (DoclingDocument format).

        Only JSON output is provided - markdown and HTML are generated by
        Java processors for consistent reading order application.

        Args:
            files: The PDF file to convert
            page_ranges: Page range string "start-end" (e.g., "1-5") (optional)

        Returns:
            JSON response with document content.
        """
        global converter

        if converter is None:
            return JSONResponse(
                {"status": "failure", "errors": ["Server not initialized"]},
                status_code=503,
            )

        # Parse page_ranges string to tuple
        page_range_tuple = None
        if page_ranges:
            try:
                parts = page_ranges.split("-")
                if len(parts) == 2:
                    page_range_tuple = (int(parts[0]), int(parts[1]))
            except ValueError:
                pass

        # Read and validate file size
        content = await files.read()
        if len(content) > MAX_FILE_SIZE:
            return JSONResponse(
                {
                    "status": "failure",
                    "errors": [f"File size exceeds maximum allowed ({MAX_FILE_SIZE // (1024*1024)}MB)"],
                },
                status_code=413,
            )

        # Save uploaded file to temp location
        tmp_path = None
        with tempfile.NamedTemporaryFile(suffix=".pdf", delete=False) as tmp:
            tmp.write(content)
            tmp_path = tmp.name

        try:
            start = time.perf_counter()
            if page_range_tuple:
                result = converter.convert(tmp_path, page_range=page_range_tuple)
            else:
                result = converter.convert(tmp_path)
            processing_time = time.perf_counter() - start

            # Export to JSON (DoclingDocument format)
            json_content = result.document.export_to_dict()

            # Build response compatible with docling-serve format
            response = {
                "status": "success",
                "document": {
                    "json_content": json_content,
                },
                "processing_time": processing_time,
            }

            return JSONResponse(response)

        except Exception as e:
            logger.error(f"PDF conversion failed: {e}\n{traceback.format_exc()}")
            return JSONResponse(
                {"status": "failure", "errors": ["PDF conversion failed"]},
                status_code=500,
            )
        finally:
            if tmp_path and os.path.exists(tmp_path):
                os.unlink(tmp_path)

    return app


def main():
    """Run the server."""
    _check_dependencies()
    import uvicorn

    parser = argparse.ArgumentParser(description="Docling Fast Server for opendataloader-pdf")
    parser.add_argument(
        "--host",
        default=DEFAULT_HOST,
        help=f"Host to bind to (default: {DEFAULT_HOST})",
    )
    parser.add_argument(
        "--port",
        type=int,
        default=DEFAULT_PORT,
        help=f"Port to bind to (default: {DEFAULT_PORT})",
    )
    parser.add_argument(
        "--log-level",
        default="info",
        choices=["debug", "info", "warning", "error"],
        help="Log level (default: info)",
    )
    parser.add_argument(
        "--force-ocr",
        action="store_true",
        help="Force full-page OCR on all pages (default: auto-detect)",
    )
    parser.add_argument(
        "--ocr-lang",
        type=str,
        default=None,
        help="OCR languages (comma-separated EasyOCR codes, e.g., 'ch_sim,en'). Default: EasyOCR default",
    )
    parser.add_argument(
        "--enrich-formula",
        action="store_true",
        default=False,
        help="Enable formula enrichment model (LaTeX extraction)",
    )
    parser.add_argument(
        "--no-enrich-formula",
        action="store_false",
        dest="enrich_formula",
    )
    parser.add_argument(
        "--enrich-picture-description",
        action="store_true",
        default=False,
        help="Enable picture description model (alt text generation using SmolVLM)",
    )
    parser.add_argument(
        "--no-enrich-picture-description",
        action="store_false",
        dest="enrich_picture_description",
    )
    parser.add_argument(
        "--picture-description-prompt",
        type=str,
        default=None,
        help="Custom prompt for picture description. If not set, uses default prompt optimized for charts and images.",
    )
    args = parser.parse_args()

    # Parse ocr_lang
    ocr_lang = None
    if args.ocr_lang:
        ocr_lang = [lang.strip() for lang in args.ocr_lang.split(",") if lang.strip()]

    # Build enrichment log message
    enrichments = []
    if args.enrich_formula:
        enrichments.append("formula")
    if args.enrich_picture_description:
        enrichments.append("picture-description")

    # Log GPU/CPU detection
    try:
        import torch
        if torch.cuda.is_available():
            gpu_name = torch.cuda.get_device_name(0)
            cuda_version = torch.version.cuda
            logger.info(f"GPU detected: {gpu_name} (CUDA {cuda_version})")
        else:
            logger.info("No GPU detected, using CPU.")
    except ImportError:
        logger.info("No GPU detected, using CPU. (PyTorch not installed)")

    logger.info(f"Starting Docling Fast Server on http://{args.host}:{args.port}")
    logger.info(f"OCR settings: force_ocr={args.force_ocr}, lang={ocr_lang or 'default'}")
    if enrichments:
        logger.info(f"Enrichments enabled: {', '.join(enrichments)}")

    app = create_app(
        force_ocr=args.force_ocr,
        ocr_lang=ocr_lang,
        enrich_formula=args.enrich_formula,
        enrich_picture_description=args.enrich_picture_description,
        picture_description_prompt=args.picture_description_prompt,
    )
    uvicorn.run(
        app,
        host=args.host,
        port=args.port,
        log_level=args.log_level,
    )


if __name__ == "__main__":
    main()
