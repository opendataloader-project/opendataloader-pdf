/*
 * Copyright 2025 Hancom Inc.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package com.hancom.opendataloader.pdf.utils.table_transformer;


import com.hancom.opendataloader.pdf.processors.TableTransformerProcessor;
import org.verapdf.wcag.algorithms.entities.geometry.BoundingBox;
import org.verapdf.wcag.algorithms.entities.geometry.MultiBoundingBox;
import org.verapdf.wcag.algorithms.entities.tables.tableBorders.TableBorder;
import org.verapdf.wcag.algorithms.entities.tables.tableBorders.TableBorderCell;
import org.verapdf.wcag.algorithms.entities.tables.tableBorders.TableBorderRow;
import org.verapdf.wcag.algorithms.semanticalgorithms.containers.StaticContainers;

import com.hancom.opendataloader.pdf.markdown.MarkdownGenerator;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

public class TableBorderJsonBuilder {
    protected static final Logger LOGGER = Logger.getLogger(MarkdownGenerator.class.getCanonicalName());
    private static class TableOfCells {
        public double[] table_bbox; // [xmin, ymin, xmax, ymax]
        public List<CellData> objects;
    }
    
    private static class CellData {
        public double[] bbox; // [xmin, ymin, xmax, ymax]
        public List<Integer> column_nums;
        public List<Integer> row_nums;
    }

    private TableOfCells tableOfCells;
//    private List<Double> xCoordinates;
//    private List<Double> xWidths;
//    private List<Double> yCoordinates;
//    private List<Double> yWidths;
    private TableBorderRow[] rows;
    private int numRows;
    private int numCols;
    private BoundingBox tableBoundingBox;

    private BoundingBox pageBoundingBox;
    private double dpiScaling;
    private int pageNumber;

    public TableBorderJsonBuilder(File cellsJSON, BoundingBox pageBoundingBox, double dpiScaling, int pageNumber) {
        // TODO: _object.json here to generate row bboxes
        this.pageBoundingBox = pageBoundingBox;
        this.dpiScaling = dpiScaling;
        this.pageNumber = pageNumber;
        ObjectMapper mapper = new ObjectMapper();
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        try {
            this.tableOfCells = mapper.readValue(cellsJSON, TableOfCells.class);
            parseData();
        } catch (JsonMappingException e) {
            LOGGER.log(Level.WARNING, "Failed to map JSON generated by TATR: " + e.getMessage());
        } catch (JsonProcessingException e) {
            LOGGER.log(Level.WARNING, "Failed to read JSON generated by TATR: " + e.getMessage());
        } catch (IOException e) {
            LOGGER.log(Level.WARNING, "Failed to open JSON file generated by TATR: " + e.getMessage());
        }
    }

    private void parseData() {
        tableBoundingBox = new BoundingBox(
            pageNumber, tableOfCells.table_bbox[0], tableOfCells.table_bbox[1], tableOfCells.table_bbox[2], tableOfCells.table_bbox[3]);
        tableBoundingBox = TableTransformerProcessor.transformBBoxFromImageToPDFCoordinates(
            tableBoundingBox, pageBoundingBox, dpiScaling);

        int maxRow = 0;
        int maxCol = 0;
        for (CellData cell : tableOfCells.objects) {
            cell.row_nums.sort(Integer::compareTo);
            cell.column_nums.sort(Integer::compareTo);
            Integer rowNum = cell.row_nums.get(cell.row_nums.size() - 1);
            if (rowNum > maxRow) {
                maxRow = rowNum;
            }
            Integer colNum = cell.column_nums.get(cell.column_nums.size() - 1);
            if (colNum > maxCol) {
                maxCol = colNum;
            }
        }
        numRows = maxRow + 1;
        numCols = maxCol + 1;

        rows = new TableBorderRow[numRows];
        for (int r = 0; r < numRows; r++) {
            // TATR generates rectangular tables, so every row should have the same number of columns
            // We could check this by looking at column_nums of cells that belong to this row
            rows[r] = new TableBorderRow(r, numCols, StaticContainers.getNextID());
            // TODO: every row needs bounding box from _objects.json
//            rows[r].setBoundingBox(new BoundingBox(pageNumber, 0, 0, 0, 0));
        }

        for (CellData cell : tableOfCells.objects) {
            double[] cellBboxArr = cell.bbox;
            BoundingBox cellBBox = new BoundingBox(
                    pageNumber, cellBboxArr[0], cellBboxArr[1], cellBboxArr[2], cellBboxArr[3]);
            cellBBox = TableTransformerProcessor.transformBBoxFromImageToPDFCoordinates(
                    cellBBox, pageBoundingBox, dpiScaling);

            int startRow = cell.row_nums.get(0);
            int startCol = cell.column_nums.get(0);
            int rowSpan = cell.row_nums.size();
            int colSpan = cell.column_nums.size();

            TableBorderCell tableCell = new TableBorderCell(startRow, startCol, rowSpan, colSpan,
                    StaticContainers.getNextID());
            tableCell.setBoundingBox(cellBBox);

            for (int r = startRow; r < startRow + rowSpan; r++) {
                for (int c = startCol; c < startCol + colSpan; c++) {
                    rows[r].getCells()[c] = tableCell;
                }
            }
        }

        for (int rowNumber = 0; rowNumber < numRows; rowNumber++) {
            BoundingBox multiBoundingBox = new MultiBoundingBox();
            for (int colNumber = 0; colNumber < numCols; colNumber++) {
                if (rows[rowNumber].getCell(colNumber).getColNumber() == colNumber &&
                        rows[rowNumber].getCell(colNumber).getRowNumber() == rowNumber) {
                    multiBoundingBox.union(rows[rowNumber].getCell(colNumber).getBoundingBox());
                }
            }
            rows[rowNumber].setBoundingBox(multiBoundingBox);
        }

//        // TATR does not provide info about border width
//        xWidths = Collections.nCopies(numCols + 1, 0.0);
//        yWidths = Collections.nCopies(numRows + 1, 0.0);
//
//        // TODO: coordinates should be based on column and row bboxes from _objects.json
//        double colWidth = tableBoundingBox.getWidth() / numCols;
//        double rowHeight = tableBoundingBox.getHeight() / numRows;
//        double tableLeft = tableBoundingBox.getLeftX();
//        double tableTop = tableBoundingBox.getTopY();

//        xCoordinates = new ArrayList<>();
//        for (int i = 0; i < numCols; i++) {
//            xCoordinates.add(tableLeft + i * colWidth);
//        }
//        xCoordinates.add(tableLeft + numCols * colWidth);
//        yCoordinates = new ArrayList<>();
//        for (int i = 0; i < numRows; i++) {
//            yCoordinates.add(tableTop - i * rowHeight);
//        }
//        yCoordinates.add(tableTop - numRows * rowHeight);
    }

    public TableBorder build() {
        if (tableOfCells == null) {
            return null;
        }
        return new TableBorder(
                tableBoundingBox,
//                xCoordinates,
//                xWidths,
//                yCoordinates,
//                yWidths,
                rows,
                numRows,
                numCols
        );
    }
}
