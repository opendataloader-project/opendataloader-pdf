name: "AI Issue: Stage 3 - Fix"

on:
  workflow_call:
    inputs:
      issue_number:
        description: 'Issue number to fix'
        required: true
        type: number
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to fix'
        required: true
        type: number
  issue_comment:
    types: [created]

env:
  # Daily limit for auto-fix runs
  # Adjustment guide:
  # - 0: Disabled (run locally with "claude @ai-issue fix #123")
  # - 3: Conservative (~$3-15/day)
  # - 5: Standard (~$5-25/day)
  # - 10: Aggressive (~$10-50/day)
  # Note: Claude Code CLI + full build/test ~$1-5/call
  DAILY_LIMIT: 3

jobs:
  fix:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: write
      pull-requests: write
      actions: read

    steps:
      - name: Check trigger conditions
        id: trigger
        env:
          # Pass user input via env vars to prevent shell injection
          COMMENT_BODY: ${{ github.event.comment.body }}
          COMMENTER_TYPE: ${{ github.event.comment.user.type }}
        run: |
          echo "=== Trigger Check ==="
          echo "Event: ${{ github.event_name }}"
          echo "Input issue_number: ${{ inputs.issue_number }}"

          SHOULD_RUN="false"
          SKIP_REASON=""
          NEEDS_AUTH="false"

          # workflow_call passes inputs.issue_number, but github.event_name stays as original event (e.g., 'issues')
          # So we detect workflow_call by checking if inputs.issue_number is set
          if [ -n "${{ inputs.issue_number }}" ]; then
            echo "âœ… Trigger via workflow_call or workflow_dispatch (issue_number=${{ inputs.issue_number }})"
            SHOULD_RUN="true"
          elif [ "${{ github.event_name }}" = "issue_comment" ]; then
            # Use env vars (not direct interpolation) for security
            echo "Comment body: $COMMENT_BODY"
            echo "Commenter type: $COMMENTER_TYPE"

            if echo "$COMMENT_BODY" | grep -q "@ai-issue fix"; then
              if [ "$COMMENTER_TYPE" != "Bot" ]; then
                echo "âœ… @ai-issue fix command detected from non-bot user"
                SHOULD_RUN="true"
                NEEDS_AUTH="true"
              else
                SKIP_REASON="@ai-issue fix command from Bot is ignored"
              fi
            else
              SKIP_REASON="Comment does not contain '@ai-issue fix' command"
            fi
          else
            SKIP_REASON="Unknown trigger: event=${{ github.event_name }}, no issue_number input"
          fi

          echo "should_run=$SHOULD_RUN" >> $GITHUB_OUTPUT
          echo "skip_reason=$SKIP_REASON" >> $GITHUB_OUTPUT
          echo "needs_auth=$NEEDS_AUTH" >> $GITHUB_OUTPUT

          if [ "$SHOULD_RUN" = "false" ]; then
            echo "âš ï¸ Skipping: $SKIP_REASON"
          fi

      - uses: actions/checkout@v4
        if: steps.trigger.outputs.needs_auth == 'true'

      - name: Check CODEOWNERS permission
        if: steps.trigger.outputs.needs_auth == 'true'
        id: auth
        env:
          # Pass user input via env vars to prevent shell injection
          COMMENTER: ${{ github.event.comment.user.login }}
        run: |

          # Parse CODEOWNERS file - extract all @usernames
          OWNERS=$(grep -oE '@[a-zA-Z0-9_-]+' .github/CODEOWNERS | sort -u | tr '\n' ' ')

          if echo "$OWNERS" | grep -qw "@$COMMENTER"; then
            echo "authorized=true" >> $GITHUB_OUTPUT
            echo "âœ… $COMMENTER is a CODEOWNER"
          else
            echo "authorized=false" >> $GITHUB_OUTPUT
            echo "âŒ $COMMENTER is not a CODEOWNER"
          fi

      - name: Check preconditions
        if: |
          steps.trigger.outputs.should_run == 'true' &&
          (steps.trigger.outputs.needs_auth != 'true' || steps.auth.outputs.authorized == 'true')
        id: check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # inputs.issue_number is set for workflow_call and workflow_dispatch
          if [ -n "${{ inputs.issue_number }}" ]; then
            ISSUE_NUM=${{ inputs.issue_number }}
          else
            ISSUE_NUM=${{ github.event.issue.number }}
          fi
          echo "issue_num=$ISSUE_NUM" >> $GITHUB_OUTPUT

          # Check daily limit
          TODAY=$(date -u +%Y-%m-%d)
          COUNT=$(gh api \
            "/repos/${{ github.repository }}/actions/workflows/ai-issue-3-fix.yml/runs?status=success&created=>=$TODAY" \
            --jq '.total_count')

          echo "Today's runs: $COUNT / $DAILY_LIMIT"
          if [ "$COUNT" -ge "$DAILY_LIMIT" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "reason=Daily limit reached ($COUNT/$DAILY_LIMIT)" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "skip=false" >> $GITHUB_OUTPUT

      - name: Skip notification
        if: |
          steps.trigger.outputs.should_run != 'true' ||
          (steps.trigger.outputs.needs_auth == 'true' && steps.auth.outputs.authorized != 'true') ||
          steps.check.outputs.skip == 'true'
        env:
          # Pass user input via env vars to prevent shell injection
          COMMENTER_LOGIN: ${{ github.event.comment.user.login }}
        run: |
          if [ "${{ steps.trigger.outputs.should_run }}" != "true" ]; then
            echo "âš ï¸ Trigger condition not met: ${{ steps.trigger.outputs.skip_reason }}"
          elif [ "${{ steps.trigger.outputs.needs_auth }}" = "true" ] && [ "${{ steps.auth.outputs.authorized }}" != "true" ]; then
            echo "âš ï¸ Authorization failed: $COMMENTER_LOGIN is not a CODEOWNER"
          else
            echo "âš ï¸ Precondition not met: ${{ steps.check.outputs.reason }}"
          fi

      - uses: actions/checkout@v4
        if: steps.check.outputs.skip == 'false'

      - name: Setup Java
        if: steps.check.outputs.skip == 'false'
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Setup Python
        if: steps.check.outputs.skip == 'false'
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Setup Node.js
        if: steps.check.outputs.skip == 'false'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        if: steps.check.outputs.skip == 'false'
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Gather context
        if: steps.check.outputs.skip == 'false'
        id: context
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_NUM=${{ steps.check.outputs.issue_num }}

          # Get full issue details including comments
          gh issue view $ISSUE_NUM --json title,body,labels,comments > /tmp/issue.json

          # Extract title for PR
          ISSUE_TITLE=$(cat /tmp/issue.json | jq -r '.title')
          echo "title=$ISSUE_TITLE" >> $GITHUB_OUTPUT

          # Extract AI Analysis comment (starts with "## ðŸ” AI Analysis"), truncate to 2000 chars
          AI_ANALYSIS=$(cat /tmp/issue.json | jq -r '.comments[] | select(.body | startswith("## ðŸ” AI Analysis")) | .body' | head -c 2000)
          echo "$AI_ANALYSIS" > /tmp/ai_analysis.txt

          # Extract @ai-issue fix comment (contains additional instructions), truncate to 500 chars
          FIX_INSTRUCTION=$(cat /tmp/issue.json | jq -r '.comments[] | select(.body | contains("@ai-issue fix")) | .body' | head -c 500)
          echo "$FIX_INSTRUCTION" > /tmp/fix_instruction.txt

      - name: Run fix
        if: steps.check.outputs.skip == 'false'
        id: fix
        timeout-minutes: 30
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # Pass user-derived input via env vars to prevent shell injection
          ISSUE_TITLE: ${{ steps.context.outputs.title }}
        run: |
          ISSUE_NUM=${{ steps.check.outputs.issue_num }}

          # Create branch
          BRANCH="ai-fix/issue-$ISSUE_NUM"
          git checkout -b "$BRANCH"

          # Build prompt using shared script (outputs template with placeholders)
          FIX_PROMPT=$(.github/scripts/ai-issue/build-stage3-prompt.sh)

          # Replace placeholders
          AI_ANALYSIS=$(cat /tmp/ai_analysis.txt 2>/dev/null || echo "No analysis available")
          FIX_INSTRUCTION=$(cat /tmp/fix_instruction.txt 2>/dev/null || echo "")
          FIX_PROMPT="${FIX_PROMPT//ISSUE_NUM_PLACEHOLDER/$ISSUE_NUM}"
          FIX_PROMPT="${FIX_PROMPT//ISSUE_TITLE_PLACEHOLDER/$ISSUE_TITLE}"
          FIX_PROMPT="${FIX_PROMPT//AI_ANALYSIS_PLACEHOLDER/$AI_ANALYSIS}"
          FIX_PROMPT="${FIX_PROMPT//FIX_INSTRUCTION_PLACEHOLDER/$FIX_INSTRUCTION}"

          # Save prompt to file (avoid argument length limits)
          echo "$FIX_PROMPT" > /tmp/fix_prompt.txt

          # Run Claude Code CLI
          FIX_RESULT=$(cat /tmp/fix_prompt.txt | npx -y @anthropic-ai/claude-code \
            --print \
            --verbose \
            --allowedTools "Read,Glob,Grep,Edit,Write,Bash" \
            2>&1 || echo "FIX_FAILED")

          echo "=== Fix Result ==="
          echo "$FIX_RESULT"
          echo "=================="

          # Check for critical errors that should abort immediately
          if echo "$FIX_RESULT" | grep -q "Prompt is too long"; then
            echo "âŒ Fix aborted: Prompt is too long"
            echo "fix_failed=true" >> $GITHUB_OUTPUT
            echo "fail_reason=Prompt is too long - issue context exceeds Claude's limits" >> $GITHUB_OUTPUT
            exit 0
          fi

          if echo "$FIX_RESULT" | grep -q "FIX_FAILED"; then
            echo "âŒ Fix aborted: Claude Code CLI failed"
            echo "fix_failed=true" >> $GITHUB_OUTPUT
            echo "fail_reason=Claude Code CLI returned an error" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Parse response using shared script
          PARSED=$(echo "$FIX_RESULT" | .github/scripts/ai-issue/parse-stage3-response.sh /tmp)

          echo "=== Parsed Result ==="
          echo "$PARSED"
          echo "====================="

          # Check if parsing was successful
          if echo "$PARSED" | grep -q "success=false"; then
            echo "âŒ Fix aborted: No valid fix summary found"
            echo "fix_failed=true" >> $GITHUB_OUTPUT
            echo "fail_reason=Fix did not produce a valid summary" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check if fix was successful (has changes)
          if [ -n "$(git status --porcelain)" ]; then
            # Get list of changed files
            CHANGED_FILES=$(git diff --name-only HEAD)
            echo "$CHANGED_FILES" > /tmp/changed_files.txt

            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "fix_failed=false" >> $GITHUB_OUTPUT
            echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "fix_failed=true" >> $GITHUB_OUTPUT
            echo "fail_reason=No changes were made" >> $GITHUB_OUTPUT
          fi

      - name: Commit and push
        if: steps.check.outputs.skip == 'false' && steps.fix.outputs.fix_failed != 'true' && steps.fix.outputs.has_changes == 'true'
        id: commit
        env:
          ISSUE_NUM: ${{ steps.check.outputs.issue_num }}
          ISSUE_TITLE: ${{ steps.context.outputs.title }}
          BRANCH: ${{ steps.fix.outputs.branch }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "fix: resolve issue #$ISSUE_NUM - $ISSUE_TITLE

          ðŸ¤– Generated with Claude Code

          Co-Authored-By: Claude <noreply@anthropic.com>"

          git push origin "$BRANCH"

          echo "success=true" >> $GITHUB_OUTPUT

      - name: Create pull request
        if: steps.check.outputs.skip == 'false' && steps.fix.outputs.fix_failed != 'true' && steps.commit.outputs.success == 'true'
        id: pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCH: ${{ steps.fix.outputs.branch }}
          # Pass user-derived input via env vars to prevent shell injection
          ISSUE_TITLE: ${{ steps.context.outputs.title }}
        run: |
          ISSUE_NUM=${{ steps.check.outputs.issue_num }}

          SUMMARY_SECTION=$(cat /tmp/fix_summary.txt)
          CHANGED_FILES=$(cat /tmp/changed_files.txt)

          # Read understanding from parsed file (created by parse-stage3-response.sh)
          UNDERSTANDING=$(cat /tmp/fix_understanding.txt 2>/dev/null || echo "")
          if [ -z "$UNDERSTANDING" ]; then
            UNDERSTANDING="(No understanding summary provided)"
          fi

          # Build PR body
          PR_BODY=$(cat <<EOF
          ## Summary
          Automated fix for #$ISSUE_NUM: **$ISSUE_TITLE**

          ## AI's Understanding of the Issue
          > $UNDERSTANDING

          ## AI Fix Details
          \`\`\`
          $SUMMARY_SECTION
          \`\`\`

          ## Changed Files
          \`\`\`
          $CHANGED_FILES
          \`\`\`

          ## Test Plan
          - [ ] Tests pass
          - [ ] Build succeeds
          - [ ] Manual verification

          ---
          ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

          Closes #$ISSUE_NUM
          EOF
          )

          # Create PR
          PR_URL=$(gh pr create \
            --title "fix: resolve issue #$ISSUE_NUM - $ISSUE_TITLE" \
            --body "$PR_BODY" \
            --base main \
            --head "$BRANCH")

          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT

      - name: "Result: Success"
        if: steps.check.outputs.skip == 'false' && steps.fix.outputs.fix_failed != 'true' && steps.commit.outputs.success == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_URL: ${{ steps.pr.outputs.pr_url }}
        run: |
          ISSUE_NUM=${{ steps.check.outputs.issue_num }}

          COMMENT=$(cat <<EOF
          ## ðŸŽ‰ Auto-Fix Complete

          I've analyzed this issue and created a fix!

          **Pull Request:** $PR_URL

          âœ… All builds and tests passed before creating this PR.

          Please review the changes and merge if everything looks good.

          ---
          ðŸ¤– *This fix was generated by AI and may be inaccurate or inappropriate. Please review carefully before merging!*
          EOF
          )

          gh issue comment $ISSUE_NUM --body "$COMMENT"

      - name: "Result: Fix Failed (Critical Error)"
        if: steps.check.outputs.skip == 'false' && steps.fix.outputs.fix_failed == 'true'
        env:
          FAIL_REASON: ${{ steps.fix.outputs.fail_reason }}
        run: |
          # Log the failure but do NOT create a PR or comment on the issue
          echo "âŒ Auto-fix failed: $FAIL_REASON"
          echo "Skipping PR creation and issue comment due to critical error."
          echo "The issue will need manual attention."

